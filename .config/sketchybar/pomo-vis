#!/bin/bash

POMO_DIR="$HOME/.config/sketchybar/pomodoro"
HISTORY_FILE="$POMO_DIR/.pomodoro_history"

# Default to 7 days
DAYS=7
VIEW_MODE="chart"  # Default view mode

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--days)
            DAYS="$2"
            shift 2
            ;;
        --timeline)
            VIEW_MODE="timeline"
            shift
            ;;
        -h|--help)
            echo "Usage: pomo-vis [options]"
            echo "Visualize your pomodoro session history"
            echo ""
            echo "Options:"
            echo "  -d, --days N    Show last N days (default: 7)"
            echo "  --timeline       Show timeline view instead of bar chart"
            echo "  -h, --help      Show this help message"
            echo ""
            echo "Examples:"
            echo "  pomo-vis -d 2          # Show last 2 days as bar chart"
            echo "  pomo-vis --timeline    # Show today's timeline"
            echo "  pomo-vis --timeline -d 3  # Show last 3 days as timeline"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use 'pomo-vis --help' for usage information"
            exit 1
            ;;
    esac
done

# Check if history file exists
if [ ! -f "$HISTORY_FILE" ]; then
    echo "No pomodoro history found."
    exit 0
fi

echo "📊 Pomodoro Sessions (Last $DAYS days)"
echo ""

# Get the date N days ago
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS date command
    START_DATE=$(date -v-${DAYS}d "+%Y-%m-%d")
else
    # Linux date command
    START_DATE=$(date -d "$DAYS days ago" "+%Y-%m-%d")
fi

# Filter history for work sessions in date range
FILTERED_SESSIONS=$(awk -v start="$START_DATE" '
    {
        # Extract date from timestamp
        date = $1
        # Only include work sessions (not breaks) from start date onwards
        if ($3 != "[BREAK]" && date >= start) {
            print $0
        }
    }
' "$HISTORY_FILE")

# Check if we have any sessions
if [ -z "$FILTERED_SESSIONS" ]; then
    echo "No work sessions found in the last $DAYS days."
    exit 0
fi

# Display based on view mode
if [ "$VIEW_MODE" = "timeline" ]; then
    # For timeline, we want ALL sessions (including breaks)
    ALL_SESSIONS=$(awk -v start="$START_DATE" '
        {
            # Extract date from timestamp
            date = $1
            # Include all sessions from start date onwards
            if (date >= start) {
                print $0
            }
        }
    ' "$HISTORY_FILE")
    
    # Check if we have any sessions for timeline
    if [ -z "$ALL_SESSIONS" ]; then
        echo "No sessions found in the last $DAYS days."
        exit 0
    fi
    
    # Sort sessions by timestamp for timeline
    SORTED_SESSIONS=$(echo "$ALL_SESSIONS" | sort)
    
    # Determine title based on days
    if [ "$DAYS" = "1" ]; then
        echo "📅 Today's Sessions:"
    else
        echo "📅 Last $DAYS days Sessions:"
    fi
    echo ""
    
    # Process sessions and group by hour
    CURRENT_HOUR=""
    CURRENT_DATE=""
    echo "$SORTED_SESSIONS" | while read line; do
        # Extract date, time and session info
        DATE=$(echo "$line" | awk '{print $1}')
        TIME=$(echo "$line" | awk '{print $2}')
        HOUR=$(echo "$TIME" | cut -d: -f1)
        MINUTE=$(echo "$TIME" | cut -d: -f2)
        
        # Extract task name and duration
        TASK=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')
        DURATION=$(echo "$line" | awk '{for(i=1;i<=NF;i++) if($i=="mins") print $(i-1)}')
        
        # Print date header if new date
        if [ "$DATE" != "$CURRENT_DATE" ] && [ "$DAYS" != "1" ]; then
            CURRENT_DATE="$DATE"
            CURRENT_HOUR=""  # Reset hour for new date
            echo ""
            echo "── $DATE ──"
            echo ""
        fi
        
        # Add spacing between different hours
        if [ "$HOUR" != "$CURRENT_HOUR" ]; then
            if [ -n "$CURRENT_HOUR" ]; then
                echo "      │"  # Add a visual separator between hours
            fi
            CURRENT_HOUR="$HOUR"
        fi
        
        # Determine icon based on task type
        if [ "$TASK" = "BREAK" ]; then
            ICON="☕️"
        else
            ICON="🍅"
        fi
        
        # Format time as HH:MM
        TIME_FORMATTED=$(printf "%s:%s" "$HOUR" "$MINUTE")
        
        # Print session with proper alignment
        # Format: "HH:MM ┤ 🍅 Task Name (25m)"
        printf "%5s ┤ %s %-30s (%sm)\n" "$TIME_FORMATTED" "$ICON" "$TASK" "$DURATION"
    done
    
    # Calculate and show summary
    echo ""
    echo "──────────────────────────────────────────────"
    TOTAL_MINUTES=$(echo "$SORTED_SESSIONS" | awk '
        {
            for (i = 1; i <= NF; i++) {
                if ($i == "mins") {
                    total += $(i-1)
                }
            }
        }
        END { print total }
    ')
    TOTAL_HOURS=$(echo "scale=1; $TOTAL_MINUTES / 60" | bc)
    WORK_SESSIONS=$(echo "$SORTED_SESSIONS" | grep -v "\[BREAK\]" | wc -l | tr -d ' ')
    BREAK_SESSIONS=$(echo "$SORTED_SESSIONS" | grep "\[BREAK\]" | wc -l | tr -d ' ')
    
    echo "Total: $TOTAL_HOURS hours ($WORK_SESSIONS work, $BREAK_SESSIONS breaks)"
    
    exit 0
fi

# Calculate total hours per day
DAILY_HOURS=$(echo "$FILTERED_SESSIONS" | awk '
    {
        date = $1
        # Extract minutes from the log entry (e.g., "30 mins")
        for (i = 1; i <= NF; i++) {
            if ($i == "mins") {
                minutes = $(i-1)
                hours[date] += minutes / 60.0
                break
            }
        }
    }
    END {
        for (d in hours) {
            printf "%s %.1f\n", d, hours[d]
        }
    }
' | sort)

# Find max hours for scaling
MAX_HOURS=$(echo "$DAILY_HOURS" | awk '{if ($2 > max) max = $2} END {print max}')

# Draw bar chart
echo "Daily Hours:"
echo ""
echo "$DAILY_HOURS" | while read date hours; do
    # Calculate bar length (max 40 chars)
    if (( $(echo "$MAX_HOURS > 0" | bc -l) )); then
        BAR_LENGTH=$(echo "scale=0; $hours * 40 / $MAX_HOURS" | bc)
    else
        BAR_LENGTH=0
    fi
    
    # Create bar
    BAR=$(printf '█%.0s' $(seq 1 $BAR_LENGTH))
    
    # Print formatted line
    printf "%-10s  %-40s %.1f hours\n" "$date" "$BAR" "$hours"
done

# Count task frequency
echo ""
echo "Tasks:"
echo ""
TASK_HOURS=$(echo "$FILTERED_SESSIONS" | awk '
    {
        # Extract task name - find text between [ and ]
        start = index($0, "[")
        end = index($0, "]")
        if (start > 0 && end > start) {
            task = substr($0, start + 1, end - start - 1)
            # Find minutes
            for (i = 1; i <= NF; i++) {
                if ($i == "mins" && i > 1) {
                    minutes = $(i-1)
                    hours[task] += minutes / 60.0
                    break
                }
            }
        }
    }
    END {
        for (t in hours) {
            printf "%.1f %s\n", hours[t], t
        }
    }
' | sort -nr | head -10)

# Find max task hours for scaling
MAX_TASK_HOURS=$(echo "$TASK_HOURS" | awk '{if ($1 > max) max = $1} END {print max}')

# Show task breakdown
echo "$TASK_HOURS" | while read hours task; do
    # Calculate bar length (max 20 chars for tasks)
    if (( $(echo "$MAX_TASK_HOURS > 0" | bc -l) )); then
        BAR_LENGTH=$(echo "scale=0; $hours * 20 / $MAX_TASK_HOURS" | bc)
    else
        BAR_LENGTH=0
    fi
    
    # Create bar
    BAR=$(printf '█%.0s' $(seq 1 $BAR_LENGTH))
    
    # Print formatted line
    printf "• %-30s %-20s %.1fh\n" "$task" "$BAR" "$hours"
done